---
title: 'Proteomics data analysis with promor: technical replicates'
author: "Chathurani Ranathunge"
package: promor
output:
  html_document:
    latex_engine: xelatex
    df_print: paged
    toc: true
  rmarkdown::html_vignette:
    number_sections: yes

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
This tutorial shows how you can use `promor` to analyse label-free quantification (LFQ) proteomics data that **contains technical replicates**. 

We recommend that you first go through the simple working example provided in **Introduction to promor** to get acquainted with `promor`'s functionality.
```{r, eval=FALSE}
vignette("intro_to_promor")
```

A tutorial for proteomics data **without technical replicates** is provided here:
[promor: No technical replicates](https://caranathunge.github.io/promor/articles/promor_no_techreps.html)

For this tutorial we will be using a previously published data set from [Ramond et al. (2015)](https://www.mcponline.org/article/S1535-9476(20)33188-1/fulltext). In this experiment there are two conditions or groups (D8 and WT) with three biological replicates each, and three technical replicates for each biological replicate.\

## Workflow
![promor notechreps flowchart by caranathunge](../man/figures/promor_ProtAnalysis_techreps_small.png) 
*Figure 1. A schematic diagram highlighting the suggested promor workflow for proteomics data with technical replicates*

**You can access the help pages for functions shown above and more using** `?function_name`

## Input data
To run *promor*, you need:

-  A **proteinGroups.txt** file produced by *MaxQuant*
-  An **expDesign.txt** file that contains the experimental design. 

 **proteinGroups.txt** is one of the output files generated by *MaxQuant* program.  It is a tab-delimited file that contains information on identified proteins from your peptide data. More information on its contents can be found in [MaxQuant Documentation](http://coxdocs.org/doku.php?id=maxquant:table:proteingrouptable).\
 
**expDesign.txt** file is a tab-delimited text file that contains the design of your experiment. Note that you will have to create and provide this file when you run *promor* with your own data. Let's take a look at the sample *expDesign.txt* file that we will be using for this tutorial.


```{r inputfiles}
# Load promor
library(promor)
# Let's load the expDesign.txt file
exp_design <- read.csv("https://raw.githubusercontent.com/caranathunge/promor_example_data/main/ed2.txt", sep = "\t")
# Take a peek inside the file
head(exp_design, n = 12)
```
**mq_label** is the sample label that you provided when running *MaxQuant*. You can easily find them in your *proteinGroups.txt* file. Hint: In LFQ intensity columns, the term "LFQ intensity" is immediately followed by the label you provided when running *MaxQuant*. This is your **mq_label**.

**condition** is the condition or group that your samples belong to. In this example "D8" refers to an âˆ†argP mutant cell line with Arginine Transporter inactivated and "WT" refers to Wild Type cells. 

**sample_ID** is a unique identifier for each sample or biological replicate.

**tech_rep** is a number denoting the technical replicate number. In this example, there are three technical replicates for each biological replicate (see **sample_ID**).

## 1. Create a *raw_df* object
Let's first create a *raw_df* object with the input files. Note: we have indicated that the data include technical replicates with `tech_reps = TRUE`.
```{r createdf, warning=FALSE}
#Create a raw_df object with default settings.
raw <- create_df(
prot_groups = "https://raw.githubusercontent.com/caranathunge/promor_example_data/main/pg2.txt",
exp_design = "https://raw.githubusercontent.com/caranathunge/promor_example_data/main/ed2.txt",
                 tech_reps = TRUE )
# We can quickly check how the data frame looks like
head(raw)
```
If you ran `create_df` with default settings, now your *raw_df* object contains log2 transformed LFQ protein intensity values and zeros have been converted to NAs. Run `?create_df` for more information on available arguments.

## 2. Correlation plots: technical replicates
Typically, technical replicates for each sample should show strong correlation. At this stage, we can quickly check if this is the case in our experiment. 
```{r corrplot, fig.align = 'center', fig.height = 7, warning = FALSE}
# Let's first check the correlation between tech.replicates 1 and 2
corr_plot(raw, rep_1 = 1, rep_2 = 2, n_row = 3, n_col = 2, text_size = 12)

```
Similarly, we can visualize the correlation between technical replicates 1 and 3.
```{r corrplot1, fig.height = 7, warning = FALSE, fig.align = 'center'}
# Correlation between tech.replicates 1 and 3.
corr_plot(raw, rep_1 = 1, rep_2 = 3, n_row = 3, n_col = 2, text_size = 12)
```
You can repeat the analysis for technical replicates 2 and 3 in the same manner.\

Additionally, if you identify pairs of technical replicates with weak correlation, those samples or technical replicates can be easily removed with `rem_sample` at this stage.\

Our technical replicates appear to show strong correlation, therefore we will use all three per sample to calculate average intensities in the next step.

## 3. Average intensities across technical replicates
Now, we are ready to calculate average intensity across technical replicates for each sample.

```{r avertechreps, warning = FALSE}
raw_ave <- aver_techreps(raw)

# A quick check on the dimensions of the data frame show that the number of columns is reduced from 18 to 6 as we averaged the tech.replicates.
dim(raw_ave)
```
## 4. Filter proteins by groupwise missing data
Next, we will remove proteins if they have more than 0.4% (default is 0.33%) missing data in either group.
```{r filterbygroupna, warning = FALSE}
#Filter out proteins with high levels of missing data in each condition
raw_filtered <- filterbygroup_na(raw_ave, set_na = 0.40)
# We can check the dimensions of the new data frame. Note that the number of rows has changed.
dim(raw_filtered)
```
## 5. Visualize missing data
Now, we are going to see how missing data is distributed in the data. 

```{r heatmapna1, warning = FALSE, results = 'hide', out.width='50%', fig.align = 'center'}
#Visualize missing data in a subset of proteins. 
heatmap_na(raw_filtered)
```

We can reorder proteins by their mean intensity to see if proteins with low intensity show higher levels of missing data

```{r heatmapna2, warning = FALSE, results = 'hide', out.width='50%', fig.align = 'center'}
#Visualize missing data in a subset of proteins. 
heatmap_na(raw_filtered, reorder_y = TRUE)
```


For larger data sets, you can choose to visualize subsets of the data.

```{r heatmapna3, warning = FALSE, results = 'hide', out.width='50%', fig.align = 'center'}
#Visualize missing data in a subset of proteins. 
heatmap_na(raw_filtered, protein_range = 1:40)
```

## 6. Impute missing data
*promor* provides multiple missing data imputation methods. Default is `minProb`, which assumes that all missing data is MNAR (Missing Not at Random) type. More information about available imputation methods can be found in [Lazar et al. (2016)](https://pubs.acs.org/doi/10.1021/acs.jproteome.5b00981).


```{r imputena, warning = FALSE, results='hide'}
# Impute missing data with minProb method
imp_df_mp <- impute_na(raw_filtered)

#Alternatively, we can test a different imputation method.
imp_df_svd <- impute_na(raw_filtered, method = "SVD")

```
## 7. Visualize imputed data
We can now visualize the impact of imputation on each sample's intensity data. 
First, lets check the data imputed with `minProb` method.

```{r imputeplotmp, warning = FALSE, results='hide', fig.align = 'center', dpi = 300}
# Visualize the imputed data with sample-wise density plots.
impute_plot(original = raw_filtered, imputed = imp_df_mp, global = FALSE, n_row = 3, n_col = 2)
```
It looks like some samples have been imputed with an excess of low intensity values.\

Let's look at the data imputed with the `SVD` method next.

```{r imputeplotrf, warning = FALSE, results='hide', fig.align = 'center', dpi = 300}
# Visualize the imputed data with a global density plot.
impute_plot(original = raw_filtered, imputed = imp_df_svd, global = FALSE, n_row = 3, n_col = 2)
```
Compared to `minProb`, `SVD` seems to have introduced fewer low intensity values, so let's use that data set in downstream steps.

Additionally, we can also visualize the imputed data of all six samples with a global density plot.

```{r imputeplotglobal, fig.align='center', warning = FALSE, out.width='50%', results='hide'}
# Visualize the imputed data with a global density plot.
impute_plot(original = raw_filtered, imputed = imp_df_svd, global = TRUE)
```

## 8. Normalize data

Next, we will normalize the imputed data with the default `quantile` method.
```{r norm, warning = FALSE, results='hide'}
norm_df <- normalize_data(imp_df_svd)
```


## 9. Visualize normalized data
Let's check if our data set was successfully normalized with a density plot.
```{r normplot, warning = FALSE, results = 'hide', fig.align = 'center', out.width='60%'}
norm_plot(original = imp_df_svd, normalized = norm_df, type = "density")
```

## 10. Identify differentially expressed proteins
We can now use the `norm.df` object we created in **Step 8** to perform differential expression analysis.

```{r finddep, warning = FALSE, results = 'hide'}
fit_df <- find_dep(norm_df)
```

You can also choose to save the top 10 hits in a text file as follows:
```{r tophits, warning = FALSE, eval = FALSE, results = 'hide'}
fit_df <- find_dep(norm_df, save_tophits = TRUE, n_top = 10)
```

## 11. Generate a volcano plot
Let's visualize the results from **Step 10** using a volcano plot.


```{r volcanoplot, warning = FALSE, results ='hide', fig.align = 'center', out.width='60%',}
volcano_plot(fit_df)
```

## 12. Create a heatmap of differentially expressed proteins
We can also visualize the top hits from **Step 10** with a heatmap.
```{r heatmapde, warning = FALSE, results ='hide', fig.align = 'center'}
heatmap_de(fit_df = fit_df, norm_df = norm_df)
```



